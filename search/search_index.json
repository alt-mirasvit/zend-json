{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-json Zend\\Json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . Installation Run the following to install this library: $ composer require zendframework/zend-json Documentation Browse the documentation online at https://docs.zendframework.com/zend-json/ Support Issues Chat Forum","title":"Home"},{"location":"#zend-json","text":"Zend\\Json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site .","title":"zend-json"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-json","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.zendframework.com/zend-json/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"advanced/","text":"Advanced Usage JSON Objects When encoding PHP objects as JSON, all public properties of that object will be encoded in a JSON object. JSON does not allow object references, so care should be taken not to encode objects with recursive references. If you have issues with recursion, Zend\\Json\\Json::encode() and Zend\\Json\\Encoder::encode() each allow an optional second parameter to check for recursion; if an object is serialized twice, an exception will be thrown. Decoding JSON objects poses additional difficulty, however, since JavaScript objects correspond most closely to PHP's associative array. Some suggest that a class identifier should be passed, and an object instance of that class should be created and populated with the key/value pairs of the JSON object; others feel this could pose a substantial security risk. By default, Zend\\Json\\Json will decode JSON objects as stdClass objects. However, if you desire an associative array returned, you can request it using the second argument to decode() : // Decode JSON objects as PHP array $phpNative = Zend\\Json\\Json::decode($encodedValue, Zend\\Json\\Json::TYPE_ARRAY); Any objects thus decoded are returned as associative arrays with keys and values corresponding to the key/value pairs in the JSON notation. The recommendation of Zend Framework is that the individual developer should decide how to decode JSON objects. If an object of a specified type should be created, it can be created in the developer code and populated with the values decoded using zend-json. Encoding PHP Objects If you are encoding PHP objects, the default encoding mechanism can only access public properties of these objects. When a method toJson() is implemented on an object to encode, Zend\\Json\\Json calls this method and expects the object to return a JSON representation of its internal state. Zend\\Json\\Json can encode PHP objects recursively but does not do so by default. This can be enabled by passing true as the second argument to Zend\\Json\\Json::encode() . // Encode PHP object recursively $jsonObject = Zend\\Json\\Json::encode($data, true); When doing recursive encoding of objects, as JSON does not support cycles, a Zend\\Json\\Exception\\RecursionException will be thrown. If you wish, you can silence these exceptions by passing the silenceCyclicalExceptions option: $jsonObject = Zend\\Json\\Json::encode( $data, true, ['silenceCyclicalExceptions' => true] ); Internal Encoder/Decoder Zend\\Json has two different modes depending if ext/json is enabled in your PHP installation or not. If ext/json is installed, zend-json will use the json_encode() and json_decode() functions for encoding and decoding JSON. If ext/json is not installed, a Zend Framework implementation in PHP code is used for en/decoding. This is considerably slower than using the PHP extension, but behaves exactly the same. Sometimes you might want to use the zend-json encoder/decoder even if you have ext/json installed. You can achieve this by calling: Zend\\Json\\Json::$useBuiltinEncoderDecoder = true; JSON Expressions JavaScript makes heavy use of anonymous function callbacks, which can be saved within JSON object variables. They only work if not returned inside double quotes, which zend-json implements by default. With the Expression support for zend-json, you can encode JSON objects with valid JavaScript callbacks. This works when either json_encode() or the internal encoder is used. A JavaScript callback is represented using the Zend\\Json\\Expr object. It implements the value object pattern and is immutable. You can set the JavaScript expression as the first constructor argument. By default Zend\\Json\\Json::encode() does not encode JavaScript callbacks; you have to pass the option enableJsonExprFinder and set it to TRUE when calling the encode() method. If enabled, the expression support works for all nested expressions in large object structures. As an example: $data = [ 'onClick' => new Zend\\Json\\Expr( 'function() {' . 'alert(\"I am a valid JavaScript callback created by Zend\\\\Json\"); . '}' ), 'other' => 'no expression', ]; $jsonObjectWithExpression = Zend\\Json\\Json::encode( $data, false, ['enableJsonExprFinder' => true] );","title":"Advanced Usage"},{"location":"advanced/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced/#json-objects","text":"When encoding PHP objects as JSON, all public properties of that object will be encoded in a JSON object. JSON does not allow object references, so care should be taken not to encode objects with recursive references. If you have issues with recursion, Zend\\Json\\Json::encode() and Zend\\Json\\Encoder::encode() each allow an optional second parameter to check for recursion; if an object is serialized twice, an exception will be thrown. Decoding JSON objects poses additional difficulty, however, since JavaScript objects correspond most closely to PHP's associative array. Some suggest that a class identifier should be passed, and an object instance of that class should be created and populated with the key/value pairs of the JSON object; others feel this could pose a substantial security risk. By default, Zend\\Json\\Json will decode JSON objects as stdClass objects. However, if you desire an associative array returned, you can request it using the second argument to decode() : // Decode JSON objects as PHP array $phpNative = Zend\\Json\\Json::decode($encodedValue, Zend\\Json\\Json::TYPE_ARRAY); Any objects thus decoded are returned as associative arrays with keys and values corresponding to the key/value pairs in the JSON notation. The recommendation of Zend Framework is that the individual developer should decide how to decode JSON objects. If an object of a specified type should be created, it can be created in the developer code and populated with the values decoded using zend-json.","title":"JSON Objects"},{"location":"advanced/#encoding-php-objects","text":"If you are encoding PHP objects, the default encoding mechanism can only access public properties of these objects. When a method toJson() is implemented on an object to encode, Zend\\Json\\Json calls this method and expects the object to return a JSON representation of its internal state. Zend\\Json\\Json can encode PHP objects recursively but does not do so by default. This can be enabled by passing true as the second argument to Zend\\Json\\Json::encode() . // Encode PHP object recursively $jsonObject = Zend\\Json\\Json::encode($data, true); When doing recursive encoding of objects, as JSON does not support cycles, a Zend\\Json\\Exception\\RecursionException will be thrown. If you wish, you can silence these exceptions by passing the silenceCyclicalExceptions option: $jsonObject = Zend\\Json\\Json::encode( $data, true, ['silenceCyclicalExceptions' => true] );","title":"Encoding PHP Objects"},{"location":"advanced/#internal-encoderdecoder","text":"Zend\\Json has two different modes depending if ext/json is enabled in your PHP installation or not. If ext/json is installed, zend-json will use the json_encode() and json_decode() functions for encoding and decoding JSON. If ext/json is not installed, a Zend Framework implementation in PHP code is used for en/decoding. This is considerably slower than using the PHP extension, but behaves exactly the same. Sometimes you might want to use the zend-json encoder/decoder even if you have ext/json installed. You can achieve this by calling: Zend\\Json\\Json::$useBuiltinEncoderDecoder = true;","title":"Internal Encoder/Decoder"},{"location":"advanced/#json-expressions","text":"JavaScript makes heavy use of anonymous function callbacks, which can be saved within JSON object variables. They only work if not returned inside double quotes, which zend-json implements by default. With the Expression support for zend-json, you can encode JSON objects with valid JavaScript callbacks. This works when either json_encode() or the internal encoder is used. A JavaScript callback is represented using the Zend\\Json\\Expr object. It implements the value object pattern and is immutable. You can set the JavaScript expression as the first constructor argument. By default Zend\\Json\\Json::encode() does not encode JavaScript callbacks; you have to pass the option enableJsonExprFinder and set it to TRUE when calling the encode() method. If enabled, the expression support works for all nested expressions in large object structures. As an example: $data = [ 'onClick' => new Zend\\Json\\Expr( 'function() {' . 'alert(\"I am a valid JavaScript callback created by Zend\\\\Json\"); . '}' ), 'other' => 'no expression', ]; $jsonObjectWithExpression = Zend\\Json\\Json::encode( $data, false, ['enableJsonExprFinder' => true] );","title":"JSON Expressions"},{"location":"basics/","text":"Basic Usage Usage of zend-json involves using two public static methods: Zend\\Json\\Json::encode() and Zend\\Json\\Json::decode() . // Decode a JSON value to PHP: $phpNative = Zend\\Json\\Json::decode($encodedValue); // Encode a PHP value to JSON: $json = Zend\\Json\\Json::encode($phpNative); ext/json By default, the above two calls will proxy to the json_decode() and json_encode() functions of ext/json , which is bundled in default installations of PHP. Using zend-json, however, ensures that the functionality works regardless of whether or not the extension is available. Additionally, the component provides some features not found in ext/json , such as encoding native JSON expressions, communicating class inheritance, and customizations around pretty printing. Pretty-printing JSON Sometimes, it may be hard to explore JSON data generated by Zend\\Json\\Json::encode() , since it has no spacing or indentation. In order to make it easier, Zend\\Json\\Json allows you to pretty-print JSON data in the human-readable format with Zend\\Json\\Json::prettyPrint() . // Encode it to return to the client: $json = Zend\\Json\\Json::encode($phpNative); if ($debug) { echo Zend\\Json\\Json::prettyPrint($json, array('indent' => ' ')); } The second, optional, argument to Zend\\Json\\Json::prettyPrint() is an option array. Option indent allows providing an indentation string; by default, it uses four spaces.","title":"Basic Usage"},{"location":"basics/#basic-usage","text":"Usage of zend-json involves using two public static methods: Zend\\Json\\Json::encode() and Zend\\Json\\Json::decode() . // Decode a JSON value to PHP: $phpNative = Zend\\Json\\Json::decode($encodedValue); // Encode a PHP value to JSON: $json = Zend\\Json\\Json::encode($phpNative);","title":"Basic Usage"},{"location":"basics/#pretty-printing-json","text":"Sometimes, it may be hard to explore JSON data generated by Zend\\Json\\Json::encode() , since it has no spacing or indentation. In order to make it easier, Zend\\Json\\Json allows you to pretty-print JSON data in the human-readable format with Zend\\Json\\Json::prettyPrint() . // Encode it to return to the client: $json = Zend\\Json\\Json::encode($phpNative); if ($debug) { echo Zend\\Json\\Json::prettyPrint($json, array('indent' => ' ')); } The second, optional, argument to Zend\\Json\\Json::prettyPrint() is an option array. Option indent allows providing an indentation string; by default, it uses four spaces.","title":"Pretty-printing JSON"},{"location":"intro/","text":"Introduction zend-json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . JSON, JavaScript Object Notation, can be used for data interchange between JavaScript and other languages. Since JSON can be directly evaluated by JavaScript, it is a more efficient and lightweight format than XML for exchanging data with JavaScript clients.","title":"Introduction"},{"location":"intro/#introduction","text":"zend-json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . JSON, JavaScript Object Notation, can be used for data interchange between JavaScript and other languages. Since JSON can be directly evaluated by JavaScript, it is a more efficient and lightweight format than XML for exchanging data with JavaScript clients.","title":"Introduction"},{"location":"migration/v2-to-v3/","text":"Migrating from v2 to v3 Version 3 is the first significant departure in the zend-json API. In particular, it features the removal of two features to new packages. zend-json-server The Zend\\Json\\Server subcomponent was extracted to a new component, zend-json-server . Install it using: $ composer install zendframework/zend-json-server All classes and functionality remain the same as in previous versions of zend-json. XML to JSON support v2 releases of zend-json provided Zend\\Json\\Json::fromXml() , which could be used to convert an XML document to JSON. This functionality has been extracted to a new component, zend-xml2json . Install it using: $ composer install zendframework/zend-xml2json In order to use the functionality, you will need to modify your calls from Zend\\Json\\Json::fromXml() to instead use Zend\\Xml2Json\\Xml2Json::fromXml() .","title":"From v2 to v3"},{"location":"migration/v2-to-v3/#migrating-from-v2-to-v3","text":"Version 3 is the first significant departure in the zend-json API. In particular, it features the removal of two features to new packages.","title":"Migrating from v2 to v3"},{"location":"migration/v2-to-v3/#zend-json-server","text":"The Zend\\Json\\Server subcomponent was extracted to a new component, zend-json-server . Install it using: $ composer install zendframework/zend-json-server All classes and functionality remain the same as in previous versions of zend-json.","title":"zend-json-server"},{"location":"migration/v2-to-v3/#xml-to-json-support","text":"v2 releases of zend-json provided Zend\\Json\\Json::fromXml() , which could be used to convert an XML document to JSON. This functionality has been extracted to a new component, zend-xml2json . Install it using: $ composer install zendframework/zend-xml2json In order to use the functionality, you will need to modify your calls from Zend\\Json\\Json::fromXml() to instead use Zend\\Xml2Json\\Xml2Json::fromXml() .","title":"XML to JSON support"}]}